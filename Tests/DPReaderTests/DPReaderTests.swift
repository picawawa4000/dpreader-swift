import Foundation
import Testing
@testable import DPReader

// Note: .testingAttributes is dynamically generated by TestVisible, so it does exist, even if the IDE complains that it doesn't.

/// Compare the JSON structure of a string to an expected value.
/// - Parameters:
///   - actual: The actual return value of some serialization function.
///   - expected: The expected JSON structure of the return value. Can be encoded as a string or passed in as raw data.
/// - Returns: Whether the JSON structures match.
func checkJSON(_ actual: Data, _ expected: Any) throws -> Bool {
    func normalizeJSON(_ obj: Any) -> Any {
        // Normalize NS types to Swift types for easier comparisons.
        if obj is NSNull { return NSNull() }
        if let n = obj as? NSNumber { return n }
        if let s = obj as? NSString { return String(s) }
        if let dict = obj as? [String: Any] {
            var normalized: [String: Any] = [:]
            for (k, v) in dict {
                normalized[k] = normalizeJSON(v)
            }
            return normalized
        }
        if let arr = obj as? [Any] {
            return arr.map { normalizeJSON($0) }
        }
        return obj
    }

    func compare(_ a: Any, _ b: Any) -> Bool {
        switch (a, b) {
        case (is NSNull, is NSNull):
            return true
        case let (x as String, y as String):
            return x == y
        case let (x as NSNumber, y as NSNumber):
            // Compare numeric values robustly
            return x == y || x.doubleValue == y.doubleValue
        case let (x as [Any], y as [Any]):
            guard x.count == y.count else { return false }
            for (lx, ry) in zip(x, y) {
                if !compare(lx, ry) { return false }
            }
            return true
        case let (x as [String: Any], y as [String: Any]):
            let xKeys = Set(x.keys)
            let yKeys = Set(y.keys)
            guard xKeys == yKeys else { return false }
            for key in xKeys {
                if !compare(x[key] as Any, y[key] as Any) { return false }
            }
            return true
        default:
            return false
        }
    }

    // Parse actual JSON data
    //guard let actualData = actual.data(using: .utf8) else {
    //    return false
    //}
    let actualObj = try JSONSerialization.jsonObject(with: actual, options: [.allowFragments])
    let normalizedActual = normalizeJSON(actualObj)

    // Prepare expected: if it's a String, parse it as JSON; otherwise use it directly
    let normalizedExpected: Any
    if let expectedString = expected as? String {
        guard let expectedData = expectedString.data(using: .utf8) else {
            return false
        }
        let expectedObj = try JSONSerialization.jsonObject(with: expectedData, options: [.allowFragments])
        normalizedExpected = normalizeJSON(expectedObj)
    } else {
        normalizedExpected = normalizeJSON(expected)
    }

    let ret = compare(normalizedActual, normalizedExpected)
    if !ret {
        print("JSON didn't match! Expected:", expected, "but found:", String(data: actual, encoding: .utf8)!)
    }
    return ret
}

enum TestingErrors: Error {
    case testNotImplemented(String)
}
