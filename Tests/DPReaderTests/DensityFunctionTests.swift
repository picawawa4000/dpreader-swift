import Foundation
import Testing
@testable import DPReader

// Note: .testingAttributes is dynamically generated by TestVisible, so it does exist, even if the IDE complains that it doesn't.

/// Compare the JSON structure of a string to an expected value.
/// - Parameters:
///   - actual: The actual return value of some serialization function.
///   - expected: The expected JSON structure of the return value. Can be encoded as a string or passed in as raw data.
/// - Returns: Whether the JSON structures match.
private func checkJSON(_ actual: Data, _ expected: Any) throws -> Bool {
    func normalizeJSON(_ obj: Any) -> Any {
        // Normalize NS types to Swift types for easier comparisons.
        if obj is NSNull { return NSNull() }
        if let n = obj as? NSNumber { return n }
        if let s = obj as? NSString { return String(s) }
        if let dict = obj as? [String: Any] {
            var normalized: [String: Any] = [:]
            for (k, v) in dict {
                normalized[k] = normalizeJSON(v)
            }
            return normalized
        }
        if let arr = obj as? [Any] {
            return arr.map { normalizeJSON($0) }
        }
        return obj
    }

    func compare(_ a: Any, _ b: Any) -> Bool {
        switch (a, b) {
        case (is NSNull, is NSNull):
            return true
        case let (x as String, y as String):
            return x == y
        case let (x as NSNumber, y as NSNumber):
            // Compare numeric values robustly
            return x == y || x.doubleValue == y.doubleValue
        case let (x as [Any], y as [Any]):
            guard x.count == y.count else { return false }
            for (lx, ry) in zip(x, y) {
                if !compare(lx, ry) { return false }
            }
            return true
        case let (x as [String: Any], y as [String: Any]):
            let xKeys = Set(x.keys)
            let yKeys = Set(y.keys)
            guard xKeys == yKeys else { return false }
            for key in xKeys {
                if !compare(x[key] as Any, y[key] as Any) { return false }
            }
            return true
        default:
            return false
        }
    }

    // Parse actual JSON data
    //guard let actualData = actual.data(using: .utf8) else {
    //    return false
    //}
    let actualObj = try JSONSerialization.jsonObject(with: actual, options: [.allowFragments])
    let normalizedActual = normalizeJSON(actualObj)

    // Prepare expected: if it's a String, parse it as JSON; otherwise use it directly
    let normalizedExpected: Any
    if let expectedString = expected as? String {
        guard let expectedData = expectedString.data(using: .utf8) else {
            return false
        }
        let expectedObj = try JSONSerialization.jsonObject(with: expectedData, options: [.allowFragments])
        normalizedExpected = normalizeJSON(expectedObj)
    } else {
        normalizedExpected = normalizeJSON(expected)
    }

    return compare(normalizedActual, normalizedExpected)
}

private enum TestingError: Error {
    case jsonNotAnObjectError
}

// ----- SERIALIZATION (ENCODING) TESTS -----

@Test func testEncodingForReference() async throws {
    let densityFunction = ReferenceDensityFunction(target: "minecraft:continentalness")
    let encoder = JSONEncoder()
    let data = try encoder.encode(densityFunction)
    #expect(try checkJSON(data, "\"minecraft:continentalness\""))
}

/// Don't use the full notation; only use the shorthand (it's more legible).
@Test func testEncodingForConstant() async throws {
    let densityFunction = ConstantDensityFunction(value: 0.5)
    let encoder = JSONEncoder()
    let data = try encoder.encode(densityFunction)
    #expect(try checkJSON(data, 0.5))
}

@Test func testEncodingForUnaryOperation() async throws {
    let input = ConstantDensityFunction(value: 3.5)
    let abs = UnaryDensityFunction(operand: input, type: .ABS)
    let square = UnaryDensityFunction(operand: input, type: .SQUARE)
    let cube = UnaryDensityFunction(operand: input, type: .CUBE)
    let halfNegative = UnaryDensityFunction(operand: input, type: .HALF_NEGATIVE)
    let quarterNegative = UnaryDensityFunction(operand: input, type: .QUARTER_NEGATIVE)
    let squeeze = UnaryDensityFunction(operand: input, type: .SQUEEZE)
    let invert = UnaryDensityFunction(operand: input, type: .INVERT)
    let encoder = JSONEncoder()
    let absData = try encoder.encode(abs)
    let squareData = try encoder.encode(square)
    let cubeData = try encoder.encode(cube)
    let halfNegativeData = try encoder.encode(halfNegative)
    let quarterNegativeData = try encoder.encode(quarterNegative)
    let squeezeData = try encoder.encode(squeeze)
    let invertData = try encoder.encode(invert)
    #expect(try checkJSON(absData, [
        "type": "minecraft:abs",
        "argument": 3.5
    ]))
    #expect(try checkJSON(squareData, [
        "type": "minecraft:square",
        "argument": 3.5
    ]))
    #expect(try checkJSON(cubeData, [
        "type": "minecraft:cube",
        "argument": 3.5
    ]))
    #expect(try checkJSON(halfNegativeData, [
        "type": "minecraft:half_negative",
        "argument": 3.5
    ]))
    #expect(try checkJSON(quarterNegativeData, [
        "type": "minecraft:quarter_negative",
        "argument": 3.5
    ]))
    #expect(try checkJSON(squeezeData, [
        "type": "minecraft:squeeze",
        "argument": 3.5
    ]))
    #expect(try checkJSON(invertData, [
        "type": "minecraft:invert",
        "argument": 3.5
    ]))
}

@Test func testEncodingForBinaryOperation() async throws {
    let a = ConstantDensityFunction(value: 1.5)
    let b = ConstantDensityFunction(value: 2.0)
    let add = BinaryDensityFunction(firstOperand: a, secondOperand: b, type: .ADD)
    let multiply = BinaryDensityFunction(firstOperand: a, secondOperand: b, type: .MULTIPLY)
    let maximum = BinaryDensityFunction(firstOperand: a, secondOperand: b, type: .MAXIMUM)
    let minimum = BinaryDensityFunction(firstOperand: a, secondOperand: b, type: .MINIMUM)
    let encoder = JSONEncoder()
    let addData = try encoder.encode(add)
    let mulData = try encoder.encode(multiply)
    let maxData = try encoder.encode(maximum)
    let minData = try encoder.encode(minimum)
    #expect(try checkJSON(addData, [
        "type": "minecraft:add",
        "argument1": 1.5,
        "argument2": 2.0
    ]))
    #expect(try checkJSON(mulData, [
        "type": "minecraft:mul",
        "argument1": 1.5,
        "argument2": 2.0
    ]))
    #expect(try checkJSON(maxData, [
        "type": "minecraft:max",
        "argument1": 1.5,
        "argument2": 2.0
    ]))
    #expect(try checkJSON(minData, [
        "type": "minecraft:min",
        "argument1": 1.5,
        "argument2": 2.0
    ]))
}

@Test func testEncodingForClamp() async throws {
    let input = ConstantDensityFunction(value: 0.7)
    let clamp = ClampDensityFunction(input: input, lowerBound: -1.0, upperBound: 1.0)
    let encoder = JSONEncoder()
    let data = try encoder.encode(clamp)
    #expect(try checkJSON(data, [
        "type": "minecraft:clamp",
        "input": 0.7,
        "min": -1.0,
        "max": 1.0
    ]))
}

@Test func testEncodingForYClampedGradient() async throws {
    let grad = YClampedGradient(fromY: 0, toY: 64, fromValue: -1.0, toValue: 1.0)
    let encoder = JSONEncoder()
    let data = try encoder.encode(grad)
    #expect(try checkJSON(data, [
        "type": "minecraft:y_clamped_gradient",
        "from_y": 0,
        "to_y": 64,
        "from_value": -1.0,
        "to_value": 1.0
    ]))
}

@Test func testEncodingForRangeChoice() async throws {
    let input = ConstantDensityFunction(value: 0.5)
    let inRange = ConstantDensityFunction(value: 10.0)
    let outRange = ConstantDensityFunction(value: -10.0)
    let rangeChoice = RangeChoice(inputChoice: input, minInclusive: 0.0, maxExclusive: 1.0, whenInRange: inRange, whenOutOfRange: outRange)
    let encoder = JSONEncoder()
    let data = try encoder.encode(rangeChoice)
    #expect(try checkJSON(data, [
        "type": "minecraft:range_choice",
        "min_inclusive": 0.0,
        "max_exclusive": 1.0,
        "input": 0.5,
        "when_in_range": 10.0,
        "when_out_of_range": -10.0
    ]))
}

@Test func testEncodingForShift() async throws {
    let shift = ShiftDensityFunction(noiseKey: "minecraft:some_noise", shiftType: .SHIFT_ALL)
    let shiftA = ShiftDensityFunction(noiseKey: "minecraft:noise_a", shiftType: .SHIFT_XZ)
    let shiftB = ShiftDensityFunction(noiseKey: "minecraft:noise_b", shiftType: .SHIFT_ZX)
    let encoder = JSONEncoder()
    let data = try encoder.encode(shift)
    let dataA = try encoder.encode(shiftA)
    let dataB = try encoder.encode(shiftB)
    #expect(try checkJSON(data, [
        "type": "minecraft:shift",
        "argument": "minecraft:some_noise"
    ]))
    #expect(try checkJSON(dataA, [
        "type": "minecraft:shift_a",
        "argument": "minecraft:noise_a"
    ]))
    #expect(try checkJSON(dataB, [
        "type": "minecraft:shift_b",
        "argument": "minecraft:noise_b"
    ]))
}

@Test func testEncodingForShiftedNoise() async throws {
    let sx = ConstantDensityFunction(value: 1.0)
    let sy = ConstantDensityFunction(value: 2.0)
    let sz = ConstantDensityFunction(value: 3.0)
    let shifted = ShiftedNoise(noiseKey: "minecraft:noise", shiftX: sx, shiftY: sy, shiftZ: sz, scaleXZ: 0.25, scaleY: 0.5)
    let encoder = JSONEncoder()
    let data = try encoder.encode(shifted)
    // Note: current implementation encodes the "noise" key and the shift/scale keys, but does not include a "type" key due to a double-encode bug. Expect the final keys to include the noise name under "noise".
    #expect(try checkJSON(data, [
        "shift_x": 1.0,
        "shift_y": 2.0,
        "shift_z": 3.0,
        "xz_scale": 0.25,
        "y_scale": 0.5,
        "noise": "minecraft:noise"
    ]))
}

// ----- DESERIALIZATION (DECODING) TESTS -----

@Test func testDecodingForReference() async throws {
    let data = """
        "minecraft:erosion"
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let densityFunction = try decoder.decode(DensityFunctionInitializer.self, from: data).value
    #expect((densityFunction as! ReferenceDensityFunction).targetKey.name == "minecraft:erosion")
}

@Test func testDecodingForConstant() async throws {
    let shorthandData = """
        0.5
    """.data(using: .utf8)!
    let fullData = """
        {
            "type": "minecraft:constant",
            "value": 0.5
        }
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let shorthandDensityFunction = try decoder.decode(DensityFunctionInitializer.self, from: shorthandData).value
    let fullDensityFunction = try decoder.decode(DensityFunctionInitializer.self, from: fullData).value
    #expect((shorthandDensityFunction as! ConstantDensityFunction).testingAttributes.value == 0.5)
    #expect((fullDensityFunction as! ConstantDensityFunction).testingAttributes.value == 0.5)
}

@Test func testDecodingForUnaryOperation() async throws {
    let absData = """
        {"type": "minecraft:abs", "argument": 3.5}
    """.data(using: .utf8)!
    let squareData = """
        {"type": "minecraft:square", "argument": 3.5}
    """.data(using: .utf8)!
    let cubeData = """
        {"type": "minecraft:cube", "argument": 3.5}
    """.data(using: .utf8)!
    let halfNegativeData = """
        {"type": "minecraft:half_negative", "argument": 3.5}
    """.data(using: .utf8)!
    let quarterNegativeData = """
        {"type": "minecraft:quarter_negative", "argument": 3.5}
    """.data(using: .utf8)!
    let squeezeData = """
        {"type": "minecraft:squeeze", "argument": 3.5}
    """.data(using: .utf8)!
    let invertData = """
        {"type": "minecraft:invert", "argument": 3.5}
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let absDensity = try decoder.decode(DensityFunctionInitializer.self, from: absData).value
    let squareDensity = try decoder.decode(DensityFunctionInitializer.self, from: squareData).value
    let cubeDensity = try decoder.decode(DensityFunctionInitializer.self, from: cubeData).value
    let halfNegativeDensity = try decoder.decode(DensityFunctionInitializer.self, from: halfNegativeData).value
    let quarterNegativeDensity = try decoder.decode(DensityFunctionInitializer.self, from: quarterNegativeData).value
    let squeezeDensity = try decoder.decode(DensityFunctionInitializer.self, from: squeezeData).value
    let invertDensity = try decoder.decode(DensityFunctionInitializer.self, from: invertData).value

    let absUnary = absDensity as! UnaryDensityFunction
    let squareUnary = squareDensity as! UnaryDensityFunction
    let cubeUnary = cubeDensity as! UnaryDensityFunction
    let halfNegativeUnary = halfNegativeDensity as! UnaryDensityFunction
    let quarterNegativeUnary = quarterNegativeDensity as! UnaryDensityFunction
    let squeezeUnary = squeezeDensity as! UnaryDensityFunction
    let invertUnary = invertDensity as! UnaryDensityFunction

    #expect(absUnary.testingAttributes.operation == UnaryDensityFunction.OperationType.ABS)
    #expect(squareUnary.testingAttributes.operation == UnaryDensityFunction.OperationType.SQUARE)
    #expect(cubeUnary.testingAttributes.operation == UnaryDensityFunction.OperationType.CUBE)
    #expect(halfNegativeUnary.testingAttributes.operation == UnaryDensityFunction.OperationType.HALF_NEGATIVE)
    #expect(quarterNegativeUnary.testingAttributes.operation == UnaryDensityFunction.OperationType.QUARTER_NEGATIVE)
    #expect(squeezeUnary.testingAttributes.operation == UnaryDensityFunction.OperationType.SQUEEZE)
    #expect(invertUnary.testingAttributes.operation == UnaryDensityFunction.OperationType.INVERT)

    #expect((absUnary.testingAttributes.operand as! ConstantDensityFunction).testingAttributes.value == 3.5)
    #expect((squareUnary.testingAttributes.operand as! ConstantDensityFunction).testingAttributes.value == 3.5)
    #expect((cubeUnary.testingAttributes.operand as! ConstantDensityFunction).testingAttributes.value == 3.5)
    #expect((halfNegativeUnary.testingAttributes.operand as! ConstantDensityFunction).testingAttributes.value == 3.5)
    #expect((quarterNegativeUnary.testingAttributes.operand as! ConstantDensityFunction).testingAttributes.value == 3.5)
    #expect((squeezeUnary.testingAttributes.operand as! ConstantDensityFunction).testingAttributes.value == 3.5)
    #expect((invertUnary.testingAttributes.operand as! ConstantDensityFunction).testingAttributes.value == 3.5)
}

@Test func testDecodingForBinaryOperation() async throws {
    // Only test the "add" variant here because the decoder selects variants based on the "type" key and the OperationType raw values must match.
    let data = """
    {
        "type": "minecraft:add",
        "argument1": 1.5,
        "argument2": 2.0
    }
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let densityFunction = try decoder.decode(DensityFunctionInitializer.self, from: data).value
    let binary = densityFunction as! BinaryDensityFunction
    #expect(binary.testingAttributes.operation == BinaryDensityFunction.OperationType.ADD)
    #expect((binary.testingAttributes.first as! ConstantDensityFunction).testingAttributes.value == 1.5)
    #expect((binary.testingAttributes.second as! ConstantDensityFunction).testingAttributes.value == 2.0)
}

@Test func testDecodingForClamp() async throws {
    let data = """
    {
        "type": "minecraft:clamp",
        "input": 3.0,
        "min": -5.0,
        "max": 5.0
    }
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let df = try decoder.decode(DensityFunctionInitializer.self, from: data).value
    let clamp = df as! ClampDensityFunction
    #expect((clamp.testingAttributes.input as! ConstantDensityFunction).testingAttributes.value == 3.0)
    #expect(clamp.testingAttributes.lowerBound == -5.0)
    #expect(clamp.testingAttributes.upperBound == 5.0)
}

@Test func testDecodingForYClampedGradient() async throws {
    let data = """
    {
        "type": "minecraft:y_clamped_gradient",
        "from_y": -10,
        "to_y": 20,
        "from_value": -0.5,
        "to_value": 0.75
    }
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let df = try decoder.decode(DensityFunctionInitializer.self, from: data).value
    let grad = df as! YClampedGradient
    #expect(grad.testingAttributes.fromY == -10)
    #expect(grad.testingAttributes.toY == 20)
    #expect(grad.testingAttributes.fromValue == -0.5)
    #expect(grad.testingAttributes.toValue == 0.75)
}

@Test func testDecodingForRangeChoice() async throws {
    let data = """
    {
        "type": "minecraft:range_choice",
        "min_inclusive": 0.0,
        "max_exclusive": 1.0,
        "input": 0.5,
        "when_in_range": 2.0,
        "when_out_of_range": 3.0
    }
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let df = try decoder.decode(DensityFunctionInitializer.self, from: data).value
    let rc = df as! RangeChoice
    #expect((rc.testingAttributes.inputChoice as! ConstantDensityFunction).testingAttributes.value == 0.5)
    #expect(rc.testingAttributes.minInclusive == 0.0)
    #expect(rc.testingAttributes.maxExclusive == 1.0)
    #expect((rc.testingAttributes.whenInRange as! ConstantDensityFunction).testingAttributes.value == 2.0)
    #expect((rc.testingAttributes.whenOutOfRange as! ConstantDensityFunction).testingAttributes.value == 3.0)
}

@Test func testDecodingForShift() async throws {
    let data = """
    {
        "type": "minecraft:shift",
        "argument": "minecraft:example_noise"
    }
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let df = try decoder.decode(DensityFunctionInitializer.self, from: data).value
    let shift = df as! ShiftDensityFunction
    #expect(shift.testingAttributes.shiftType == ShiftDensityFunction.ShiftType.SHIFT_ALL)
    #expect(shift.testingAttributes.noise.key.name == "minecraft:example_noise")
}

@Test func testDecodingForShiftedNoise() async throws {
    let data = """
    {
        "type": "minecraft:shifted_noise",
        "shift_x": 1.0,
        "shift_y": 2.0,
        "shift_z": 3.0,
        "xz_scale": 0.25,
        "y_scale": 0.5,
        "noise": "minecraft:shifted_noise_example"
    }
    """.data(using: .utf8)!
    let decoder = JSONDecoder()
    let df = try decoder.decode(DensityFunctionInitializer.self, from: data).value
    let sn = df as! ShiftedNoise
    #expect((sn.testingAttributes.shiftX as! ConstantDensityFunction).testingAttributes.value == 1.0)
    #expect((sn.testingAttributes.shiftY as! ConstantDensityFunction).testingAttributes.value == 2.0)
    #expect((sn.testingAttributes.shiftZ as! ConstantDensityFunction).testingAttributes.value == 3.0)
    #expect(sn.testingAttributes.scaleXZ == 0.25)
    #expect(sn.testingAttributes.scaleY == 0.5)
    // noise is an UnbakedNoise created with the registry key string
    #expect(sn.testingAttributes.noise.key.name == "minecraft:shifted_noise_example")
}

// ----- OUTPUT TESTS -----

private func checkDouble(_ actualValue: Double, _ roundedExpectedValue: Int) -> Bool {
    let roundedActualValue = Int((actualValue * 1_000_000).rounded(FloatingPointRoundingRule.toNearestOrEven))
    guard roundedExpectedValue == roundedActualValue else {
        print("Error in checkDouble: expected value", roundedExpectedValue, "did not match actual value", actualValue, "(rounded to", roundedActualValue, ")!")
        return false
    }
    return true
}

@Test func testOutputForReference() async throws {
    let referencedDensityFunction = ConstantDensityFunction(value: 20.0)
    let registry = Registry<DensityFunction>()
    let registryKey = RegistryKey<DensityFunction>(referencing: "example:test")
    registry.register(referencedDensityFunction, forKey: registryKey)
    let referenceDensityFunction = ReferenceDensityFunction(targetKey: registryKey)
    referenceDensityFunction.setDensityFunctionRegistry(registry)
    #expect(referenceDensityFunction.sample(at: PosInt3D(x: 0, y: 0, z: 0)) == 20.0)
}

@Test func testOutputForConstant() async throws {
    let densityFunction1 = ConstantDensityFunction(value: 0.5)
    let densityFunction2 = ConstantDensityFunction(value: -3.25)
    let densityFunction3 = ConstantDensityFunction(value: 10000.0)
    #expect(densityFunction1.sample(at: PosInt3D(x: -5, y: 20, z: 42)) == 0.5)
    #expect(densityFunction2.sample(at: PosInt3D(x: 0, y: 0, z: 0)) == -3.25)
    #expect(densityFunction3.sample(at: PosInt3D(x: 20, y: -4, z: 83)) == 10000.0)
}

// Copy of `squeeze` from `UnaryDensityFunction`.
private func squeeze(_ x: Double) -> Double {
    let e = clamp(value: x, lowerBound: -1.0, upperBound: 1.0)
    return e / 2.0 - e * e * e / 24.0
}

@Test func testOutputForUnaryOperation() async throws {
    let baseDensityFunction = ConstantDensityFunction(value: -0.75)

    let absDensityFunction = UnaryDensityFunction(operand: baseDensityFunction, type: .ABS)
    let squareDensityFunction = UnaryDensityFunction(operand: baseDensityFunction, type: .SQUARE)
    let cubeDensityFunction = UnaryDensityFunction(operand: baseDensityFunction, type: .CUBE)
    let halfNegativeDensityFunction = UnaryDensityFunction(operand: baseDensityFunction, type: .HALF_NEGATIVE)
    let quarterNegativeDensityFunction = UnaryDensityFunction(operand: baseDensityFunction, type: .QUARTER_NEGATIVE)
    let squeezeDensityFunction = UnaryDensityFunction(operand: baseDensityFunction, type: .SQUEEZE)
    let invertDensityFunction = UnaryDensityFunction(operand: baseDensityFunction, type: .INVERT)

    let samplingPos = PosInt3D(x: 0, y: 0, z: 0)
    #expect(absDensityFunction.sample(at: samplingPos) == 0.75)
    #expect(squareDensityFunction.sample(at: samplingPos) == 0.5625)
    #expect(cubeDensityFunction.sample(at: samplingPos) == -0.421875)
    #expect(halfNegativeDensityFunction.sample(at: samplingPos) == -0.375)
    #expect(quarterNegativeDensityFunction.sample(at: samplingPos) == -0.1875)
    #expect(squeezeDensityFunction.sample(at: samplingPos) == squeeze(-0.75))
    // Have to use `checkDouble` because `-1.333333` isn't exact.
    #expect(checkDouble(invertDensityFunction.sample(at: samplingPos), -1333333))
}

@Test func testOutputForBinaryOperation() async throws {
    let firstDensityFunction = ConstantDensityFunction(value: -0.5)
    let secondDensityFunction = ConstantDensityFunction(value: 0.75)
    
    let addDensityFunction = BinaryDensityFunction(firstOperand: firstDensityFunction, secondOperand: secondDensityFunction, type: .ADD)
    let multiplyDensityFunction = BinaryDensityFunction(firstOperand: firstDensityFunction, secondOperand: secondDensityFunction, type: .MULTIPLY)
    let maximumDensityFunction = BinaryDensityFunction(firstOperand: firstDensityFunction, secondOperand: secondDensityFunction, type: .MAXIMUM)
    let minimumDensityFunction = BinaryDensityFunction(firstOperand: firstDensityFunction, secondOperand: secondDensityFunction, type: .MINIMUM)

    let samplingPos = PosInt3D(x: 0, y: 0, z: 0)
    #expect(addDensityFunction.sample(at: samplingPos) == 0.25)
    #expect(multiplyDensityFunction.sample(at: samplingPos) == -0.375)
    #expect(maximumDensityFunction.sample(at: samplingPos) == 0.75)
    #expect(minimumDensityFunction.sample(at: samplingPos) == -0.5)
}

@Test func testOutputForClamp() async throws {
    let densityFunction1 = ClampDensityFunction(input: ConstantDensityFunction(value: 0.5), lowerBound: 0.0, upperBound: 1.0)
    let densityFunction2 = ClampDensityFunction(input: ConstantDensityFunction(value: -0.5), lowerBound: 0.0, upperBound: 1.0)
    let densityFunction3 = ClampDensityFunction(input: ConstantDensityFunction(value: 1.5), lowerBound: 0.0, upperBound: 1.0)

    let samplingPos = PosInt3D(x: 0, y: 0, z: 0)
    #expect(densityFunction1.sample(at: samplingPos) == 0.5)
    #expect(densityFunction2.sample(at: samplingPos) == 0.0)
    #expect(densityFunction3.sample(at: samplingPos) == 1.0)
}

@Test func testOutputForYClampedGradient() async throws {
    let gradient = YClampedGradient(fromY: 0, toY: 256, fromValue: -256.0, toValue: 256.0)
    #expect(gradient.sample(at: PosInt3D(x: 0, y: 128, z: 0)) == 0.0)
    #expect(gradient.sample(at: PosInt3D(x: 0, y: 512, z: 0)) == 256.0)
    #expect(gradient.sample(at: PosInt3D(x: 0, y: -256, z: 0)) == -256.0)
}

@Test func testOutputForRangeChoice() async throws {
    let inRange = ConstantDensityFunction(value: 10.0)
    let outRange = ConstantDensityFunction(value: -10.0)

    let inputInside = ConstantDensityFunction(value: 0.5)
    let rcInside = RangeChoice(inputChoice: inputInside, minInclusive: 0.0, maxExclusive: 1.0, whenInRange: inRange, whenOutOfRange: outRange)
    #expect(rcInside.sample(at: PosInt3D(x: 0, y: 0, z: 0)) == 10.0)

    let inputEdge = ConstantDensityFunction(value: 1.0)
    let rcEdge = RangeChoice(inputChoice: inputEdge, minInclusive: 0.0, maxExclusive: 1.0, whenInRange: inRange, whenOutOfRange: outRange)
    #expect(rcEdge.sample(at: PosInt3D(x: 0, y: 0, z: 0)) == -10.0)

    let inputOutside = ConstantDensityFunction(value: -5.0)
    let rcOutside = RangeChoice(inputChoice: inputOutside, minInclusive: 0.0, maxExclusive: 1.0, whenInRange: inRange, whenOutOfRange: outRange)
    #expect(rcOutside.sample(at: PosInt3D(x: 0, y: 0, z: 0)) == -10.0)
}

// Helper deterministic noise for Shift / ShiftedNoise tests.
fileprivate struct TestNoise: DensityFunctionNoise {
    let key: RegistryKey<NoiseDefinition>
    init(name: String = "test:dummy") {
        self.key = RegistryKey<NoiseDefinition>(referencing: name)
    }
    func sample(x: Double, y: Double, z: Double) -> Double {
        // Simple additive sampler so expected values are easy to compute.
        return x + y + z
    }
}

@Test func testOutputForShift() async throws {
    let noise = TestNoise()
    let shiftAll = ShiftDensityFunction(noise: noise, shiftType: .SHIFT_ALL)
    let shiftXZ = ShiftDensityFunction(noise: noise, shiftType: .SHIFT_XZ)
    let shiftZX = ShiftDensityFunction(noise: noise, shiftType: .SHIFT_ZX)

    let pos = PosInt3D(x: 1, y: 2, z: 3)
    // With TestNoise.sample(x,y,z) = x + y + z and ShiftDensityFunction logic:
    // SHIFT_ALL: 4 * noise.sample(pos*0.25) = pos.x + pos.y + pos.z
    #expect(shiftAll.sample(at: pos) == 6.0)
    // SHIFT_XZ: 4 * noise.sample(x*0.25, 0, z*0.25) = pos.x + pos.z
    #expect(shiftXZ.sample(at: pos) == 4.0)
    // SHIFT_ZX: 4 * noise.sample(z*0.25, x*0.25, 0) = pos.z + pos.x
    #expect(shiftZX.sample(at: pos) == 4.0)
}

@Test func testOutputForShiftedNoise() async throws {
    let noise = TestNoise()
    let sx = ConstantDensityFunction(value: 1.0)
    let sy = ConstantDensityFunction(value: 2.0)
    let sz = ConstantDensityFunction(value: 3.0)
    let shifted = ShiftedNoise(noise: noise, shiftX: sx, shiftY: sy, shiftZ: sz, scaleXZ: 0.25, scaleY: 0.5)

    // Choose a sampling position and compute expected by hand:
    // x' = pos.x * 0.25 + shiftX = 10 * 0.25 + 1 = 3.5
    // y' = pos.y * 0.5  + shiftY = 20 * 0.5 + 2 = 12.0
    // z' = pos.z * 0.25 + shiftZ = 30 * 0.25 + 3 = 10.5
    // noise.sample = x' + y' + z' = 3.5 + 12.0 + 10.5 = 26.0
    let pos = PosInt3D(x: 10, y: 20, z: 30)
    #expect(shifted.sample(at: pos) == 26.0)
}